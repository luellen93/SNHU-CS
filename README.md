# SNHU-CS
**1. Summarize the project and what problem it was solving.**
    The grocery store project takes in a text file that contains a list of produce that has been purchased. The project consists of a few different ways to display the information so that it is easy to determine how much of each item is included in the lsit. This project can easily be adapted to read any text file and display the information in a digestable way.
   
**2. What did you do particularly well?**
    Something I did particularly well in this project was keeping my code separated into .h and .cpp files so that it is easier to see how the code functions and what each method does.

**3. Where could you enhance your code? How would these improvements make your code more efficient, secure, and so on?**
     A place where I can enhance my code is the histogram method. I can implement a method that takes in a desired character to display instead of '*'. This way the user can display the histogram however they would prefer. Another thing I could also improve is passing the map created by reference so that I avoid altering the main map at any point. This will allow me to avoid any issue with unwanted changes.

**4. Which pieces of the code did you find most challenging to write, and how did you overcome this? What tools or resources are you adding to your support network?**
     The piece of code I found to be the most challenging was the creation of the map after reading the .txt file. Maps wasn't something that had a ton of information in ZyBooks so I had to do a lot of research using stack overflow and geeks for geeks. The way I eventually overcame this challenge was but reading about how maps worked in c++ and slowly building code to make sure I was created the map right and then iterating through it correctly.

**5. What skills from this project will be particularly transferable to other projects or course work?**
     The skills that will be transferable to other projects was my ability to learn about a new concept in the coding language and then implement it. This required me to test my code often and build my code incrementally.

**6. How did you make this program maintainable, readable, and adaptable?**
     The way I made this code maintainable, readable, and adaptable was by using inherited files and keeping my main file very short. This allows me to only need to change a few things in my .h or .cpp file to make large changes to the whole code base. Also, the main file is more readable due to calling from methods that are declared and defined elsewhere. 
  
**//CS 250 Journal**

I firmly believe that attaining mastery in this skill requires time and unwavering commitment. By maintaining transparent communication with end-users, we can systematically introduce a range of changes through incremental and straightforward releases. User stories assume a critical role in honing client requirements by addressing these fundamental questions:

Who stands to benefit from this change?
What does the user aim to achieve?
Why is this change absolutely necessary?

Since my initiation into the world of Agile methodology, I feel well-prepared to enhance my grasp of project management across a spectrum of scenarios. Organization holds a paramount position in the realm of development, and Agile provides an effective means to uphold order while preserving the virtues of flexibility and adaptability. Development teams place a premium on value-driven progress, unfettered by the constraints of stringent deadlines, thereby ensuring the consistent attainment of end-user objectives. My aspirations include the integration of software tools such as Azure, Jira, and Github into my upcoming projects. In addition, daily stand-up meetings and planning poker have evolved into foundational elements of my developer toolkit. Agile simplifies the complexity of development endeavors by prioritizing smaller tasks.

The significance of this lesson was underscored during my participation in a full-stack development bootcamp. Working collaboratively within a team characterized by diverse personalities and viewpoints, it is imperative to keep sight of the shared objective: delivering a product. The focus should not be on determining who is the superior developer or who possesses the most experience; rather, it should be on nurturing collaboration. Agile, with its emphasis on adaptability, mandates that developers also exhibit flexibility. Team members should be open to perspectives beyond their own and extend respect to differing opinions. Serving as the team leader in my bootcamp project, I ensured that every team member had a voice, whether or not consensus was reached, and each team member's ideas found a place in the project. Cultivating trust plays a pivotal role in boosting team morale and strengthening intra-team relationships. Personal development remains a cornerstone, for without the experiential foundation, growth remains hampered.

**//CS 300 Journal**

I can certainly provide you with a general response to these questions based on a typical data structures and algorithms course project.

1. **The Problem Being Solved**: In a typical data structures and algorithms course project, the primary objective is to solve a specific computational problem efficiently. These problems can range from searching and sorting algorithms to more complex challenges, such as graph algorithms, dynamic programming, or even data manipulation tasks. The choice of problem often depends on the course's curriculum and learning objectives.

2. **Approach to the Problem**: The approach to solving these problems involves several key aspects. Firstly, understanding the problem thoroughly is essential. This means breaking it down into smaller, more manageable components and identifying what data structures and algorithms might be relevant to each part. Data structures, such as arrays, linked lists, trees, and graphs, play a crucial role in representing and managing data in the problem. Algorithms, such as sorting, searching, and graph traversal algorithms, are used to manipulate and process this data efficiently. The importance of data structures and algorithms lies in their ability to optimize time and space complexity.

3. **Overcoming Roadblocks**: During the project, roadblocks are common. These challenges may involve conceptual difficulties in understanding the problem, coding errors, or performance bottlenecks. To overcome these roadblocks, it's crucial to seek help from peers, professors, or online resources. Debugging and tracing code are vital skills, as well as revisiting algorithmic concepts and practicing problem-solving. Additionally, working incrementally and testing at each step can help identify and fix issues as they arise.

4. **Expanding Approach to Software Design**: The project work in a data structures and algorithms course expands one's approach to designing software in several ways. It fosters a deeper appreciation for algorithmic efficiency, encourages the use of well-structured code, and promotes modularity. Students learn to apply appropriate data structures to different problems and gain an understanding of trade-offs between space and time complexity. This knowledge is valuable when designing software that needs to scale efficiently, making it a fundamental aspect of software engineering.

5. **Evolution of Code Quality**: A critical aspect of project work in such courses is writing code that is maintainable, readable, and adaptable. Students are encouraged to adhere to coding standards and best practices, which not only improve the quality of their code but also enhance their ability to collaborate with others. Proper documentation and clear, readable code become second nature. Moreover, by designing programs with a focus on efficiency and adaptability, students learn to anticipate changes and improvements, making their code more future-proof.

In summary, data structures and algorithms courses provide students with the essential skills and knowledge needed to solve complex computational problems efficiently. The emphasis on understanding data structures and algorithms, and their application in software design, not only prepares students for technical interviews but also equips them with valuable skills for developing high-quality, maintainable, and efficient software in the real world.
